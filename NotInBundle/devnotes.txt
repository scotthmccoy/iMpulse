typedef enum {
  UIEventSubtypeNone                              = 0,
  UIEventSubtypeMotionShake                       = 1,
  UIEventSubtypeRemoteControlPlay                 = 100,
  UIEventSubtypeRemoteControlPause                = 101,
  UIEventSubtypeRemoteControlStop                 = 102,
  UIEventSubtypeRemoteControlTogglePlayPause      = 103,
  UIEventSubtypeRemoteControlNextTrack            = 104,
  UIEventSubtypeRemoteControlPreviousTrack        = 105,
  UIEventSubtypeRemoteControlBeginSeekingBackward = 106,
  UIEventSubtypeRemoteControlEndSeekingBackward   = 107,
  UIEventSubtypeRemoteControlBeginSeekingForward  = 108,
  UIEventSubtypeRemoteControlEndSeekingForward    = 109,
} UIEventSubtype;





TODO:
One potential complication - You can put the controller into AMW mode but the iOS app is simply not going to be able to tell when you released a key.


It seems as though UITextField and UITextView share an annoying problem, where the actual cursor position is kept secret.
1) If you always change the text back to "aaaa", then it stops acknolwedging up/down keyboard arrows after the first one.
2) If you always change the selectedRange, then it happily accepts it, but future keyboard input will place the cursor on the start or end of the line, as though it had "kept going".

Range -
Had some luck by setting the range to be non-zero, but then left and right are indistinguishable from up and down. I have Hope for inspiration.

Tried toggling editable, scrollToRange, and toggling firstResponder.
Possibly the only way to continue will be to destroy/re-create the listener afterwards. This seems wasteful, but good enough, since we're not writing games using this.

Give one more try to doing it with Ranges, then just blow the whole thing up during selectionchange.




Jan 10th -
Destroying and re-creating did not work. That is just incredible. Did I find yet another big bug in iOS??

It "drills" - if you hit up a bunch, it registers them as ups, but then if you hit down, it registers them as ups until it gets back down to 0. this means after the first Up lets say, we can't distinguish up from down.

if you change the text value, it locks out input. But it even locks it out when it's a brand new TextView!!

I could try a webview maybe -_-

It's definitely creating a new TextView each time. Make sure it's using the new one?

It's using the new one...how does it get all dumb? Well, if you look at all the private methods it goes through it's pretty crazy. Someway up that ladder it's probably doing something dumb.


Okay lets create a new textview each time, NOT destroy the old one, and look at what they are doing.

Doing exactly what they said they were doing. The new one is "drilled". 

Okay what if we created one BEFORE the event? Would that work? 
Nope. The new one is still drilled.

Maybe this has something to do with changing firstResponder during a changeSelecttion. I'll try destroying and re-creating it off-thread. 
MAybe I can even use a timer on a 1-second cooldown or something. After all this is just for consuming pretend arrow key input.



Stripping out the extra crap:
The GCD stuff is neccessary. 
Swapping does not seem to be neccessary.

